#version 450

#extension GL_ARB_separate_shader_objects : enable
// #extension GL_ARB_shading_language_420pack : enable

const float height = 16.0f;
const vec4 lowColor = vec4(0.8f, 0.0f, 0.0f, 1.0f);
const vec4 midColor = vec4(1.0f, 0.5f, 0.0f, 1.0f);
const vec4 topColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);


struct Particle {
    vec3 position;
    float pad;
    vec4 color;
};

struct Emitter {
    vec3 position;
    float size;
};

layout(local_size_x = 32, local_size_y = 32) in;

layout(std430, binding = 0) buffer Particles
{
    Particle particles[];
};

layout(std430, binding = 1) buffer Emitters
{
    Emitter emitters[];
};

layout(std140, binding = 2) uniform Time
{
    float sec;
    float secDelta;
};

// Based on https://thebookofshaders.com/10/
float rand(float v)
{
    return fract(sin(v) * 69301.11f);
}

// Based on https://thebookofshaders.com/11/
float noise(float v)
{
    float i = floor(v);
    float f = fract(v);
    return mix(rand(i), rand(i + 1.0f), smoothstep(0.0f, 1.0f, f));
}

float modHeight(float v)
{
    return v - floor(v * (1.0f / height)) * height;
}

void main()
{
    Emitter emitter = emitters[gl_WorkGroupID.x];
    uint index = gl_WorkGroupID.x * (gl_WorkGroupSize.x * gl_WorkGroupSize.y) + gl_LocalInvocationIndex;
    vec3 localPos = particles[index].position - emitter.position;
    float snowflake = rand(index);
    float offsetY = modHeight(snowflake * height + sec * (snowflake + 1.0f) * 4.0f);
    float offsetX = (noise(gl_LocalInvocationID.x + sec) * 2.0f - 1.0f) * emitter.size;
    float offsetZ = (noise(gl_LocalInvocationID.z + sec) * 2.0f - 1.0f) * emitter.size;
    offsetX = gl_LocalInvocationID.x;
    offsetZ = gl_LocalInvocationID.y;
    particles[index].position = emitter.position + vec3(offsetX, offsetY, offsetZ);
    particles[index].color = mix(
        mix(
            lowColor,
            midColor,
            smoothstep(0.0f, height * 0.3f, offsetY)),
        topColor,
        smoothstep(height * 0.3f, height, offsetY));
}
